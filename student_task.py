def get_count_char(str_):
    letters = str_.lower() 
    dictionary = {} # можно упростить до dict - очень популярное название переменной
    for i in letters:  
        if i.isalpha():  
            if i in dictionary.keys():  # существует более подходящий способ итерироваться по ключам словаря
                count = dictionary[i]  
                count += 1  
                dictionary[i] = count  # последовательность действий с 7 по 9 строку можно упростить до одной строки.
            else:  
                dictionary[i] = 1 # а еще можно почитать как работает defaultdict из библиотеки collections.
                                  # Тогда мы бы могли избавиться здесь от конструкции if/else
    return dictionary 


def get_percent_correlation(str_):
    cor = get_count_char(str_) # cor - не очень говорящее название переменной
    summary = sum(cor.values()) 
    for key in cor: 
        cor[key] /= summary # последовательность действий с 20 по 22 строку можно упростить до одной строки.
        cor[key] *= 100 
        cor[key] = round(cor[key]) # для большей точности можно использовать дробную часть (до двух знаков)
    return cor 


main_str = """
        Данное предложение будет разбиваться на отдельные слова. 
        В качестве разделителя для встроенного метода split будет выбран символ пробела. На выходе мы получим список 
        отдельных слов. 
        Далее нужно отсортировать слова в алфавитном порядке, а после сортировки склеить их с помощью метода строк join.
        Приступим!!!!
    """

print(get_count_char(main_str))  # Вывод словаря "Буква" - "Количество"
# print(get_percent_correlation(main_str))  # Вывод словаря "Буква" - "Процентное соотношение (данная буква/все буквы)"

# Общий комментариий: В целом, хорошо. Нет ошибок c точки зрения алгоритмической сложности. Указал, где можно уменьшить кол-во операций
# над переменными. И надо бы еще добавить type hints.
# Похвально, что написал дополнительную функцию, вычисляющую наличие букв в тексте в процентном соотношении.
